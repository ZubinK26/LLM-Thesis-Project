import spacy

# Initialize the spaCy NLP pipeline once globally.
_spacy_nlp_negation_hedging = None

def _initialize_spacy_nlp_negation_hedging():
    """Initializes and returns the spaCy NLP pipeline for negation and hedging detection."""
    global _spacy_nlp_negation_hedging
    if _spacy_nlp_negation_hedging is None:
        try:
            print("Initializing spaCy NLP pipeline for negation and hedging...")
            _spacy_nlp_negation_hedging = spacy.load("en_core_web_md")
            print("spaCy NLP pipeline for negation and hedging initialized successfully.")
        except OSError:
            print("Error: spaCy model 'en_core_web_md' not found. Please run: python -m spacy download en_core_web_md")
            _spacy_nlp_negation_hedging = None
        except Exception as e:
            print(f"An unexpected error occurred while loading spaCy for negation and hedging: {e}")
            _spacy_nlp_negation_hedging = None
    return _spacy_nlp_negation_hedging

def measure_negation_hedging(text):
    """
    Identifies and counts negation and hedging markers using predefined keyword lists
    and spaCy for text normalization (lowercasing, lemmatization).

    Args:
        text (str): The input text to analyze.

    Returns:
        dict: A dictionary containing the following metrics:
              - 'negation_count': Integer count of negation markers.
              - 'hedging_count': Integer count of hedging markers.
              - 'detected_negations': List of strings, e.g., "'not' (Lemma: not)".
              - 'detected_hedging': List of strings.
              - 'success': Boolean indicating if the operation was successful.
              - 'error_message': String with error details if any.
    """
    results = {
        'negation_count': 0,
        'hedging_count': 0,
        'detected_negations': [],
        'detected_hedging': [],
        'success': False,
        'error_message': None
    }

    nlp = _initialize_spacy_nlp_negation_hedging()
    if nlp is None:
        results['error_message'] = "spaCy NLP pipeline failed to initialize for negation and hedging."
        return results

    # --- Keyword Lists (Generated by LLM, can be expanded/modified) ---
    negation_keywords = {
        "not", "n't", "no", "never", "none", "nothing", "nowhere", "nobody", "nor",
        "hardly", "scarcely", "barely", "seldom", "rarely", "without", "lack", "fail",
        "refuse", "deny"
    }
    # Note: Prefixes like "un-", "non-" etc. are harder to detect purely by token matching.
    # For a simple test, we focus on full words/lemmas. More advanced methods would involve
    # custom tokenization or rule-based matching on word beginnings.

    hedging_keywords = {
        "might", "may", "could", "would", "should", # modal verbs
        "seems", "appears", "suggests", "indicates", "believes", "thinks",
        "assumes", "presumes", "speculates", "postulates", "hypothesizes",
        "possibly", "probably", "likely", "unlikely", "apparently", "evidently",
        "seemingly", "reportedly", "allegedly", "ostensibly", "presumably",
        "to some extent", "somewhat", "rather", "quite", "about", "around", # approximations
        "almost", "nearly", "approximately", "roughly", "often", "sometimes"
    }
    # For multi-word phrases like "in my opinion", "it seems that", "it is possible that",
    # these would ideally be handled by PhraseMatcher, similar to Domain-Specific Terms.
    # For this current implementation, they are treated as simple string checks.

    try:
        doc = nlp(text)

        # To prevent duplicate counting of the same lemma/phrase if it's detected multiple ways
        unique_negation_matches = set()
        unique_hedging_matches = set()

        # Iterate over tokens to match against keyword lists
        for token in doc:
            lemma_lower = token.lemma_.lower()
            text_lower = token.text.lower() # For direct text matching (e.g., "n't")

            # Check for negation keywords
            if (lemma_lower in negation_keywords or text_lower in negation_keywords) and lemma_lower not in unique_negation_matches:
                results['negation_count'] += 1
                results['detected_negations'].append(f"'{token.text}' (Lemma: {token.lemma_})")
                unique_negation_matches.add(lemma_lower)
            elif token.text.lower() == "n't" and "not" not in unique_negation_matches: # Specific handling for "n't"
                results['negation_count'] += 1
                results['detected_negations'].append(f"'{token.text}' (Lemma: {token.lemma_})")
                unique_negation_matches.add("not") # Use "not" as the canonical form for uniqueness

            # Check for hedging keywords
            if (lemma_lower in hedging_keywords or text_lower in hedging_keywords) and lemma_lower not in unique_hedging_matches:
                results['hedging_count'] += 1
                results['detected_hedging'].append(f"'{token.text}' (Lemma: {token.lemma_})")
                unique_hedging_matches.add(lemma_lower)
        
        # Simple multi-word phrase check for hedging (can be expanded with PhraseMatcher if needed)
        # These are hardcoded for simplicity in this test, but ideally would be loaded from a file
        # or handled by PhraseMatcher for scalability.
        text_lower_full = text.lower()
        if "in my opinion" in text_lower_full and "in my opinion" not in unique_hedging_matches:
            results['hedging_count'] += 1
            results['detected_hedging'].append("'in my opinion' (Phrase)")
            unique_hedging_matches.add("in my opinion")
        if "it seems that" in text_lower_full and "it seems that" not in unique_hedging_matches:
            results['hedging_count'] += 1
            results['detected_hedging'].append("'it seems that' (Phrase)")
            unique_hedging_matches.add("it seems that")
        if "it is possible that" in text_lower_full and "it is possible that" not in unique_hedging_matches:
            results['hedging_count'] += 1
            results['detected_hedging'].append("'it is possible that' (Phrase)")
            unique_hedging_matches.add("it is possible that")

        results['success'] = True

    except Exception as e:
        results['error_message'] = f"An error occurred during negation and hedging detection processing: {e}"
        results['success'] = False

    return results

if __name__ == "__main__":
    print("--- Running Negation and Hedging Dimension Test (Standalone) ---")

    # Test Case 1: Simple negation and hedging
    test_text_1 = "He did not believe it was possible, but he might try anyway."
    print(f"\nAnalyzing Text 1: '{test_text_1}'")
    results_1 = measure_negation_hedging(test_text_1)
    if results_1['success']:
        print("\nResults for Text 1:")
        print(f"  Negation Count: {results_1['negation_count']}")
        print(f"  Detected Negations: {results_1['detected_negations']}")
        print(f"  Hedging Count: {results_1['hedging_count']}")
        print(f"  Detected Hedging: {results_1['detected_hedging']}")
    else:
        print(f"  Error: {results_1['error_message']}")

    print("\n" + "="*70 + "\n")

    # Test Case 2: Multiple hedging words
    test_text_2 = "It seems likely that she could perhaps arrive approximately by noon."
    print(f"\nAnalyzing Text 2: '{test_text_2}'")
    results_2 = measure_negation_hedging(test_text_2)
    if results_2['success']:
        print("\nResults for Text 2:")
        print(f"  Negation Count: {results_2['negation_count']}")
        print(f"  Detected Negations: {results_2['detected_negations']}")
        print(f"  Hedging Count: {results_2['hedging_count']}")
        print(f"  Detected Hedging: {results_2['detected_hedging']}")
    else:
        print(f"  Error: {results_2['error_message']}")

    print("\n" + "="*70 + "\n")

    # Test Case 3: Sentence with no obvious markers
    test_text_3 = "The sun shines brightly today."
    print(f"\nAnalyzing Text 3: '{test_text_3}'")
    results_3 = measure_negation_hedging(test_text_3)
    if results_3['success']:
        print("\nResults for Text 3:")
        print(f"  Negation Count: {results_3['negation_count']}")
        print(f"  Detected Negations: {results_3['detected_negations']}")
        print(f"  Hedging Count: {results_3['hedging_count']}")
        print(f"  Detected Hedging: {results_3['detected_hedging']}")
    else:
        print(f"  Error: {results_3['error_message']}")

    print("\n" + "="*70 + "\n")

    # Test Case 4: Testing contractions and less common negations/hedges, including multi-word phrase
    test_text_4 = "I haven't seen anything like it. She rarely complains, but it appears she's somewhat upset. In my opinion, it is possible that this plan could fail."
    print(f"\nAnalyzing Text 4: '{test_text_4}'")
    results_4 = measure_negation_hedging(test_text_4)
    if results_4['success']:
        print("\nResults for Text 4:")
        print(f"  Negation Count: {results_4['negation_count']}")
        print(f"  Detected Negations: {results_4['detected_negations']}")
        print(f"  Hedging Count: {results_4['hedging_count']}")
        print(f"  Detected Hedging: {results_4['detected_hedging']}")
    else:
        print(f"  Error: {results_4['error_message']}")
